import "core-js/modules/es.error.cause.js";
import "core-js/modules/es.array.push.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.regexp.to-string.js";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _Symbol from "@babel/runtime-corejs3/core-js-stable/symbol";
import _getIteratorMethod from "@babel/runtime-corejs3/core-js/get-iterator-method";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _objectWithoutProperties from "@babel/runtime-corejs3/helpers/objectWithoutProperties";
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/asyncToGenerator";
var _excluded = ["url", "body"];
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof _Symbol && _getIteratorMethod(r) || r["@@iterator"]; if (!t) { if (_Array$isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { var _context8; if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = _sliceInstanceProperty(_context8 = {}.toString.call(r)).call(_context8, 8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? _Array$from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.regexp.test.js";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _keysInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/keys";
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context6, _context7; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context6 = ownKeys(Object(t), !0)).call(_context6, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context7 = ownKeys(Object(t))).call(_context7, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
import { Readable } from 'stream';
import fetch, { Response } from 'node-fetch';
import createHttpsProxyAgent from 'https-proxy-agent';
import { createHttpRequestHandlerStreams, executeWithTimeout, isRedirect, performRedirectRequest } from './request-helper';
import { getLogger } from './util/logger';
import is from '@sindresorhus/is';

/**
 *
 */
var defaults = {};

/**
 *
 */
export function setDefaults(defaults_) {
  defaults = defaults_;
}

/**
 *
 */
function startFetchRequest(_x, _x2, _x3, _x4, _x5) {
  return _startFetchRequest.apply(this, arguments);
}
/**
 *
 */
function _startFetchRequest() {
  _startFetchRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request, options, input, output, emitter) {
    var _options$retry$status, _options$retry, _options$retry$maxRet, _options$retry2, _options$retry$minTim, _options$retry3, _options$retry$timeou, _options$retry4, _options$retry$errorC, _options$retry5, _options$retry$method, _options$retry6, _context4;
    var counter,
      logger,
      httpProxy,
      followRedirect,
      agent,
      url,
      body,
      rrequest,
      controller,
      retryCount,
      retryOpts,
      shouldRetryRequest,
      _fetchWithRetries,
      res,
      headers,
      _iterator,
      _step,
      headerName,
      response,
      _args2 = arguments;
    return _regeneratorRuntime.wrap(function _callee2$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          counter = _args2.length > 5 && _args2[5] !== undefined ? _args2[5] : 0;
          logger = getLogger('fetch');
          httpProxy = options.httpProxy, followRedirect = options.followRedirect;
          agent = httpProxy ? createHttpsProxyAgent(httpProxy) : undefined;
          url = request.url, body = request.body, rrequest = _objectWithoutProperties(request, _excluded);
          controller = new AbortController();
          retryCount = 0;
          retryOpts = {
            statusCodes: (_options$retry$status = (_options$retry = options.retry) === null || _options$retry === void 0 ? void 0 : _options$retry.statusCodes) !== null && _options$retry$status !== void 0 ? _options$retry$status : [420, 429, 500, 502, 503, 504],
            maxRetries: (_options$retry$maxRet = (_options$retry2 = options.retry) === null || _options$retry2 === void 0 ? void 0 : _options$retry2.maxRetries) !== null && _options$retry$maxRet !== void 0 ? _options$retry$maxRet : 5,
            minTimeout: (_options$retry$minTim = (_options$retry3 = options.retry) === null || _options$retry3 === void 0 ? void 0 : _options$retry3.minTimeout) !== null && _options$retry$minTim !== void 0 ? _options$retry$minTim : 500,
            timeoutFactor: (_options$retry$timeou = (_options$retry4 = options.retry) === null || _options$retry4 === void 0 ? void 0 : _options$retry4.timeoutFactor) !== null && _options$retry$timeou !== void 0 ? _options$retry$timeou : 2,
            errorCodes: (_options$retry$errorC = (_options$retry5 = options.retry) === null || _options$retry5 === void 0 ? void 0 : _options$retry5.errorCodes) !== null && _options$retry$errorC !== void 0 ? _options$retry$errorC : ['ECONNRESET', 'ECONNREFUSED', 'ENOTFOUND', 'ENETDOWN', 'ENETUNREACH', 'EHOSTDOWN', 'UND_ERR_SOCKET', 'ETIMEDOUT', 'EPIPE'],
            methods: (_options$retry$method = (_options$retry6 = options.retry) === null || _options$retry6 === void 0 ? void 0 : _options$retry6.methods) !== null && _options$retry$method !== void 0 ? _options$retry$method : ['GET', 'PUT', 'HEAD', 'OPTIONS', 'DELETE']
          };
          shouldRetryRequest = function shouldRetryRequest(maxRetry, resOrErr) {
            var _context;
            if (!_includesInstanceProperty(_context = retryOpts.methods).call(_context, request.method)) return false;
            if (resOrErr instanceof Response) {
              var _context2;
              if (_includesInstanceProperty(_context2 = retryOpts.statusCodes).call(_context2, resOrErr.status)) {
                if (maxRetry === retryCount) {
                  return false;
                } else {
                  return true;
                }
              }
              return false;
            } else {
              var _retryOpts$errorCodes;
              if (maxRetry === retryCount) return false;

              // only retry on operational errors
              // https://github.com/node-fetch/node-fetch/blob/2.x/ERROR-HANDLING.md#error-handling-with-node-fetch
              if (resOrErr.name != 'FetchError') return false;
              if (is.nodeStream(body) && Readable.isDisturbed(body)) {
                logger.debug('Body of type stream was read, unable to retry request.');
                return false;
              }
              if ('code' in resOrErr && resOrErr.code && retryOpts !== null && retryOpts !== void 0 && (_retryOpts$errorCodes = retryOpts.errorCodes) !== null && _retryOpts$errorCodes !== void 0 && _includesInstanceProperty(_retryOpts$errorCodes).call(_retryOpts$errorCodes, resOrErr.code)) return true;
              return false;
            }
          };
          _fetchWithRetries = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
              var maxRetry,
                fetchOpts,
                _res,
                error,
                _args = arguments;
              return _regeneratorRuntime.wrap(function _callee$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    maxRetry = _args.length > 0 && _args[0] !== undefined ? _args[0] : retryOpts === null || retryOpts === void 0 ? void 0 : retryOpts.maxRetries;
                    fetchOpts = _objectSpread(_objectSpread(_objectSpread({}, rrequest), input && /^(post|put|patch)$/i.test(request.method) ? {
                      body: input
                    } : {}), {}, {
                      redirect: 'manual',
                      signal: controller.signal,
                      agent: agent
                    });
                    _context3.prev = 2;
                    _context3.next = 5;
                    return fetch(url, fetchOpts);
                  case 5:
                    _res = _context3.sent;
                    if (!shouldRetryRequest(retryOpts.maxRetries, _res)) {
                      _context3.next = 16;
                      break;
                    }
                    logger.debug("retrying for the ".concat(retryCount + 1, " time"));
                    logger.debug('reason: statusCode match');
                    _context3.next = 11;
                    return sleep(retryCount === 0 ? retryOpts.minTimeout : retryOpts.minTimeout * Math.pow(retryOpts.timeoutFactor, retryCount));
                  case 11:
                    // NOTE: this event is only used by tests and will be removed at any time.
                    // jsforce may switch to node's fetch which doesn't emit this event on retries.
                    emitter.emit('retry', retryCount);
                    retryCount++;
                    _context3.next = 15;
                    return _fetchWithRetries(maxRetry);
                  case 15:
                    return _context3.abrupt("return", _context3.sent);
                  case 16:
                    return _context3.abrupt("return", _res);
                  case 19:
                    _context3.prev = 19;
                    _context3.t0 = _context3["catch"](2);
                    logger.debug('Request failed');
                    error = _context3.t0; // request was canceled by consumer (AbortController), skip retry and rethrow.
                    if (!(error.name === 'AbortError')) {
                      _context3.next = 25;
                      break;
                    }
                    throw error;
                  case 25:
                    if (!shouldRetryRequest(retryOpts.maxRetries, error)) {
                      _context3.next = 33;
                      break;
                    }
                    logger.debug("retrying for the ".concat(retryCount + 1, " time"));
                    logger.debug("Error: ".concat(_context3.t0.message));
                    _context3.next = 30;
                    return sleep(retryCount === 0 ? retryOpts.minTimeout : retryOpts.minTimeout * Math.pow(retryOpts.timeoutFactor, retryCount));
                  case 30:
                    // NOTE: this event is only used by tests and will be removed at any time.
                    // jsforce may switch to node's fetch which doesn't emit this event on retries.
                    emitter.emit('retry', retryCount);
                    retryCount++;
                    return _context3.abrupt("return", _fetchWithRetries(maxRetry));
                  case 33:
                    logger.debug('Skipping retry...');
                    if (!(maxRetry === retryCount)) {
                      _context3.next = 38;
                      break;
                    }
                    throw _context3.t0;
                  case 38:
                    throw _context3.t0;
                  case 39:
                  case "end":
                    return _context3.stop();
                }
              }, _callee, null, [[2, 19]]);
            }));
            return function fetchWithRetries() {
              return _ref.apply(this, arguments);
            };
          }();
          _context5.prev = 10;
          _context5.next = 13;
          return executeWithTimeout(_fetchWithRetries, options.timeout, function () {
            return controller.abort();
          });
        case 13:
          res = _context5.sent;
          _context5.next = 20;
          break;
        case 16:
          _context5.prev = 16;
          _context5.t0 = _context5["catch"](10);
          emitter.emit('error', _context5.t0);
          return _context5.abrupt("return");
        case 20:
          headers = {};
          _iterator = _createForOfIteratorHelper(_keysInstanceProperty(_context4 = res.headers).call(_context4));
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              headerName = _step.value;
              headers[headerName.toLowerCase()] = res.headers.get(headerName);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          response = {
            statusCode: res.status,
            headers: headers
          };
          if (!(followRedirect && isRedirect(response.statusCode))) {
            _context5.next = 27;
            break;
          }
          try {
            performRedirectRequest(request, response, followRedirect, counter, function (req) {
              return startFetchRequest(req, options, undefined, output, emitter, counter + 1);
            });
          } catch (err) {
            emitter.emit('error', err);
          }
          return _context5.abrupt("return");
        case 27:
          emitter.emit('response', response);
          res.body.pipe(output);
        case 29:
        case "end":
          return _context5.stop();
      }
    }, _callee2, null, [[10, 16]]);
  }));
  return _startFetchRequest.apply(this, arguments);
}
export default function request(req) {
  var options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = _objectSpread(_objectSpread({}, defaults), options_);
  var _createHttpRequestHan = createHttpRequestHandlerStreams(req, options),
    input = _createHttpRequestHan.input,
    output = _createHttpRequestHan.output,
    stream = _createHttpRequestHan.stream;
  startFetchRequest(req, options, input, output, stream);
  return stream;
}
var sleep = function sleep(ms) {
  return new _Promise(function (r) {
    return _setTimeout(r, ms);
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSZWFkYWJsZSIsImZldGNoIiwiUmVzcG9uc2UiLCJjcmVhdGVIdHRwc1Byb3h5QWdlbnQiLCJjcmVhdGVIdHRwUmVxdWVzdEhhbmRsZXJTdHJlYW1zIiwiZXhlY3V0ZVdpdGhUaW1lb3V0IiwiaXNSZWRpcmVjdCIsInBlcmZvcm1SZWRpcmVjdFJlcXVlc3QiLCJnZXRMb2dnZXIiLCJpcyIsImRlZmF1bHRzIiwic2V0RGVmYXVsdHMiLCJkZWZhdWx0c18iLCJzdGFydEZldGNoUmVxdWVzdCIsIl94IiwiX3gyIiwiX3gzIiwiX3g0IiwiX3g1IiwiX3N0YXJ0RmV0Y2hSZXF1ZXN0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJtYXJrIiwiX2NhbGxlZTIiLCJyZXF1ZXN0Iiwib3B0aW9ucyIsImlucHV0Iiwib3V0cHV0IiwiZW1pdHRlciIsIl9vcHRpb25zJHJldHJ5JHN0YXR1cyIsIl9vcHRpb25zJHJldHJ5IiwiX29wdGlvbnMkcmV0cnkkbWF4UmV0IiwiX29wdGlvbnMkcmV0cnkyIiwiX29wdGlvbnMkcmV0cnkkbWluVGltIiwiX29wdGlvbnMkcmV0cnkzIiwiX29wdGlvbnMkcmV0cnkkdGltZW91IiwiX29wdGlvbnMkcmV0cnk0IiwiX29wdGlvbnMkcmV0cnkkZXJyb3JDIiwiX29wdGlvbnMkcmV0cnk1IiwiX29wdGlvbnMkcmV0cnkkbWV0aG9kIiwiX29wdGlvbnMkcmV0cnk2IiwiX2NvbnRleHQ0IiwiY291bnRlciIsImxvZ2dlciIsImh0dHBQcm94eSIsImZvbGxvd1JlZGlyZWN0IiwiYWdlbnQiLCJ1cmwiLCJib2R5IiwicnJlcXVlc3QiLCJjb250cm9sbGVyIiwicmV0cnlDb3VudCIsInJldHJ5T3B0cyIsInNob3VsZFJldHJ5UmVxdWVzdCIsIl9mZXRjaFdpdGhSZXRyaWVzIiwicmVzIiwiaGVhZGVycyIsIl9pdGVyYXRvciIsIl9zdGVwIiwiaGVhZGVyTmFtZSIsInJlc3BvbnNlIiwiX2FyZ3MyIiwid3JhcCIsIl9jYWxsZWUyJCIsIl9jb250ZXh0NSIsInByZXYiLCJuZXh0IiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2V4Y2x1ZGVkIiwiQWJvcnRDb250cm9sbGVyIiwic3RhdHVzQ29kZXMiLCJyZXRyeSIsIm1heFJldHJpZXMiLCJtaW5UaW1lb3V0IiwidGltZW91dEZhY3RvciIsImVycm9yQ29kZXMiLCJtZXRob2RzIiwibWF4UmV0cnkiLCJyZXNPckVyciIsIl9jb250ZXh0IiwiX2luY2x1ZGVzSW5zdGFuY2VQcm9wZXJ0eSIsImNhbGwiLCJtZXRob2QiLCJfY29udGV4dDIiLCJzdGF0dXMiLCJfcmV0cnlPcHRzJGVycm9yQ29kZXMiLCJuYW1lIiwibm9kZVN0cmVhbSIsImlzRGlzdHVyYmVkIiwiZGVidWciLCJjb2RlIiwiZmV0Y2hXaXRoUmV0cmllcyIsIl9yZWYiLCJfY2FsbGVlIiwiZmV0Y2hPcHRzIiwiX3JlcyIsImVycm9yIiwiX2FyZ3MiLCJfY2FsbGVlJCIsIl9jb250ZXh0MyIsIl9vYmplY3RTcHJlYWQiLCJ0ZXN0IiwicmVkaXJlY3QiLCJzaWduYWwiLCJzZW50IiwiY29uY2F0Iiwic2xlZXAiLCJNYXRoIiwicG93IiwiZW1pdCIsImFicnVwdCIsInQwIiwibWVzc2FnZSIsInN0b3AiLCJ0aW1lb3V0IiwiYWJvcnQiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIl9rZXlzSW5zdGFuY2VQcm9wZXJ0eSIsInMiLCJuIiwiZG9uZSIsInZhbHVlIiwidG9Mb3dlckNhc2UiLCJnZXQiLCJlcnIiLCJlIiwiZiIsInN0YXR1c0NvZGUiLCJyZXEiLCJwaXBlIiwib3B0aW9uc18iLCJfY3JlYXRlSHR0cFJlcXVlc3RIYW4iLCJzdHJlYW0iLCJtcyIsIl9Qcm9taXNlIiwiciIsIl9zZXRUaW1lb3V0Il0sInNvdXJjZXMiOlsiLi4vc3JjL3JlcXVlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IER1cGxleCwgUmVhZGFibGUsIFdyaXRhYmxlIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBmZXRjaCwgeyBSZXNwb25zZSwgUmVxdWVzdEluaXQsIEZldGNoRXJyb3IgfSBmcm9tICdub2RlLWZldGNoJztcbmltcG9ydCBjcmVhdGVIdHRwc1Byb3h5QWdlbnQgZnJvbSAnaHR0cHMtcHJveHktYWdlbnQnO1xuaW1wb3J0IHtcbiAgY3JlYXRlSHR0cFJlcXVlc3RIYW5kbGVyU3RyZWFtcyxcbiAgZXhlY3V0ZVdpdGhUaW1lb3V0LFxuICBpc1JlZGlyZWN0LFxuICBwZXJmb3JtUmVkaXJlY3RSZXF1ZXN0LFxufSBmcm9tICcuL3JlcXVlc3QtaGVscGVyJztcbmltcG9ydCB7IEh0dHBSZXF1ZXN0LCBIdHRwUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4vdXRpbC9sb2dnZXInO1xuaW1wb3J0IGlzIGZyb20gJ0BzaW5kcmVzb3JodXMvaXMnO1xuXG4vKipcbiAqXG4gKi9cbmxldCBkZWZhdWx0czogSHR0cFJlcXVlc3RPcHRpb25zID0ge307XG5cbi8qKlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRzKGRlZmF1bHRzXzogSHR0cFJlcXVlc3RPcHRpb25zKSB7XG4gIGRlZmF1bHRzID0gZGVmYXVsdHNfO1xufVxuXG4vKipcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0YXJ0RmV0Y2hSZXF1ZXN0KFxuICByZXF1ZXN0OiBIdHRwUmVxdWVzdCxcbiAgb3B0aW9uczogSHR0cFJlcXVlc3RPcHRpb25zLFxuICBpbnB1dDogUmVhZGFibGUgfCB1bmRlZmluZWQsXG4gIG91dHB1dDogV3JpdGFibGUsXG4gIGVtaXR0ZXI6IEV2ZW50RW1pdHRlcixcbiAgY291bnRlcjogbnVtYmVyID0gMCxcbikge1xuICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoJ2ZldGNoJyk7XG4gIGNvbnN0IHsgaHR0cFByb3h5LCBmb2xsb3dSZWRpcmVjdCB9ID0gb3B0aW9ucztcbiAgY29uc3QgYWdlbnQgPSBodHRwUHJveHkgPyBjcmVhdGVIdHRwc1Byb3h5QWdlbnQoaHR0cFByb3h5KSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgeyB1cmwsIGJvZHksIC4uLnJyZXF1ZXN0IH0gPSByZXF1ZXN0O1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gIGxldCByZXRyeUNvdW50ID0gMDtcblxuICBjb25zdCByZXRyeU9wdHM6IFJlcXVpcmVkPEh0dHBSZXF1ZXN0T3B0aW9uc1sncmV0cnknXT4gPSB7XG4gICAgc3RhdHVzQ29kZXM6IG9wdGlvbnMucmV0cnk/LnN0YXR1c0NvZGVzID8/IFs0MjAsIDQyOSwgNTAwLCA1MDIsIDUwMywgNTA0XSxcbiAgICBtYXhSZXRyaWVzOiBvcHRpb25zLnJldHJ5Py5tYXhSZXRyaWVzID8/IDUsXG4gICAgbWluVGltZW91dDogb3B0aW9ucy5yZXRyeT8ubWluVGltZW91dCA/PyA1MDAsXG4gICAgdGltZW91dEZhY3Rvcjogb3B0aW9ucy5yZXRyeT8udGltZW91dEZhY3RvciA/PyAyLFxuICAgIGVycm9yQ29kZXM6IG9wdGlvbnMucmV0cnk/LmVycm9yQ29kZXMgPz8gW1xuICAgICAgJ0VDT05OUkVTRVQnLFxuICAgICAgJ0VDT05OUkVGVVNFRCcsXG4gICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICdFTkVURE9XTicsXG4gICAgICAnRU5FVFVOUkVBQ0gnLFxuICAgICAgJ0VIT1NURE9XTicsXG4gICAgICAnVU5EX0VSUl9TT0NLRVQnLFxuICAgICAgJ0VUSU1FRE9VVCcsXG4gICAgICAnRVBJUEUnLFxuICAgIF0sXG4gICAgbWV0aG9kczogb3B0aW9ucy5yZXRyeT8ubWV0aG9kcyA/PyBbXG4gICAgICAnR0VUJyxcbiAgICAgICdQVVQnLFxuICAgICAgJ0hFQUQnLFxuICAgICAgJ09QVElPTlMnLFxuICAgICAgJ0RFTEVURScsXG4gICAgXSxcbiAgfTtcblxuICBjb25zdCBzaG91bGRSZXRyeVJlcXVlc3QgPSAoXG4gICAgbWF4UmV0cnk6IG51bWJlcixcbiAgICByZXNPckVycjogUmVzcG9uc2UgfCBFcnJvciB8IEZldGNoRXJyb3IsXG4gICk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghcmV0cnlPcHRzLm1ldGhvZHMuaW5jbHVkZXMocmVxdWVzdC5tZXRob2QpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocmVzT3JFcnIgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgaWYgKHJldHJ5T3B0cy5zdGF0dXNDb2Rlcy5pbmNsdWRlcyhyZXNPckVyci5zdGF0dXMpKSB7XG4gICAgICAgIGlmIChtYXhSZXRyeSA9PT0gcmV0cnlDb3VudCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXhSZXRyeSA9PT0gcmV0cnlDb3VudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBvbmx5IHJldHJ5IG9uIG9wZXJhdGlvbmFsIGVycm9yc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9ibG9iLzIueC9FUlJPUi1IQU5ETElORy5tZCNlcnJvci1oYW5kbGluZy13aXRoLW5vZGUtZmV0Y2hcbiAgICAgIGlmIChyZXNPckVyci5uYW1lICE9ICdGZXRjaEVycm9yJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoaXMubm9kZVN0cmVhbShib2R5KSAmJiBSZWFkYWJsZS5pc0Rpc3R1cmJlZChib2R5KSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0JvZHkgb2YgdHlwZSBzdHJlYW0gd2FzIHJlYWQsIHVuYWJsZSB0byByZXRyeSByZXF1ZXN0LicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgJ2NvZGUnIGluIHJlc09yRXJyICYmXG4gICAgICAgIHJlc09yRXJyLmNvZGUgJiZcbiAgICAgICAgcmV0cnlPcHRzPy5lcnJvckNvZGVzPy5pbmNsdWRlcyhyZXNPckVyci5jb2RlKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBmZXRjaFdpdGhSZXRyaWVzID0gYXN5bmMgKFxuICAgIG1heFJldHJ5ID0gcmV0cnlPcHRzPy5tYXhSZXRyaWVzLFxuICApOiBQcm9taXNlPFJlc3BvbnNlPiA9PiB7XG4gICAgY29uc3QgZmV0Y2hPcHRzOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgIC4uLnJyZXF1ZXN0LFxuICAgICAgLi4uKGlucHV0ICYmIC9eKHBvc3R8cHV0fHBhdGNoKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKVxuICAgICAgICA/IHsgYm9keTogaW5wdXQgfVxuICAgICAgICA6IHt9KSxcbiAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICBhZ2VudCxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgZmV0Y2hPcHRzKTtcbiAgICAgIGlmIChzaG91bGRSZXRyeVJlcXVlc3QocmV0cnlPcHRzLm1heFJldHJpZXMsIHJlcykpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGByZXRyeWluZyBmb3IgdGhlICR7cmV0cnlDb3VudCArIDF9IHRpbWVgKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWFzb246IHN0YXR1c0NvZGUgbWF0Y2gnKTtcblxuICAgICAgICBhd2FpdCBzbGVlcChcbiAgICAgICAgICByZXRyeUNvdW50ID09PSAwXG4gICAgICAgICAgICA/IHJldHJ5T3B0cy5taW5UaW1lb3V0XG4gICAgICAgICAgICA6IHJldHJ5T3B0cy5taW5UaW1lb3V0ICogcmV0cnlPcHRzLnRpbWVvdXRGYWN0b3IgKiogcmV0cnlDb3VudCxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBOT1RFOiB0aGlzIGV2ZW50IGlzIG9ubHkgdXNlZCBieSB0ZXN0cyBhbmQgd2lsbCBiZSByZW1vdmVkIGF0IGFueSB0aW1lLlxuICAgICAgICAvLyBqc2ZvcmNlIG1heSBzd2l0Y2ggdG8gbm9kZSdzIGZldGNoIHdoaWNoIGRvZXNuJ3QgZW1pdCB0aGlzIGV2ZW50IG9uIHJldHJpZXMuXG4gICAgICAgIGVtaXR0ZXIuZW1pdCgncmV0cnknLCByZXRyeUNvdW50KTtcbiAgICAgICAgcmV0cnlDb3VudCsrO1xuXG4gICAgICAgIHJldHVybiBhd2FpdCBmZXRjaFdpdGhSZXRyaWVzKG1heFJldHJ5KTtcbiAgICAgIH1cbiAgICAgIC8vIHNob3VsZCB3ZSB0aHJvdyBoZXJlIGlmIHRoZSBtYXhSZXRyeSBhbHJlYWR5IGhhcHBlbmVkIGFuZCBzdGlsbCBnb3QgdGhlIHNhbWUgc3RhdHVzQ29kZT9cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgICBjb25zdCBlcnJvciA9IGVyciBhcyBFcnJvciB8IEZldGNoRXJyb3I7XG5cbiAgICAgIC8vIHJlcXVlc3Qgd2FzIGNhbmNlbGVkIGJ5IGNvbnN1bWVyIChBYm9ydENvbnRyb2xsZXIpLCBza2lwIHJldHJ5IGFuZCByZXRocm93LlxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFJldHJ5UmVxdWVzdChyZXRyeU9wdHMubWF4UmV0cmllcywgZXJyb3IpKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgcmV0cnlpbmcgZm9yIHRoZSAke3JldHJ5Q291bnQgKyAxfSB0aW1lYCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgRXJyb3I6ICR7KGVyciBhcyBFcnJvcikubWVzc2FnZX1gKTtcblxuICAgICAgICBhd2FpdCBzbGVlcChcbiAgICAgICAgICByZXRyeUNvdW50ID09PSAwXG4gICAgICAgICAgICA/IHJldHJ5T3B0cy5taW5UaW1lb3V0XG4gICAgICAgICAgICA6IHJldHJ5T3B0cy5taW5UaW1lb3V0ICogcmV0cnlPcHRzLnRpbWVvdXRGYWN0b3IgKiogcmV0cnlDb3VudCxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBOT1RFOiB0aGlzIGV2ZW50IGlzIG9ubHkgdXNlZCBieSB0ZXN0cyBhbmQgd2lsbCBiZSByZW1vdmVkIGF0IGFueSB0aW1lLlxuICAgICAgICAvLyBqc2ZvcmNlIG1heSBzd2l0Y2ggdG8gbm9kZSdzIGZldGNoIHdoaWNoIGRvZXNuJ3QgZW1pdCB0aGlzIGV2ZW50IG9uIHJldHJpZXMuXG4gICAgICAgIGVtaXR0ZXIuZW1pdCgncmV0cnknLCByZXRyeUNvdW50KTtcbiAgICAgICAgcmV0cnlDb3VudCsrO1xuXG4gICAgICAgIHJldHVybiBmZXRjaFdpdGhSZXRyaWVzKG1heFJldHJ5KTtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmRlYnVnKCdTa2lwcGluZyByZXRyeS4uLicpO1xuXG4gICAgICBpZiAobWF4UmV0cnkgPT09IHJldHJ5Q291bnQpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBsZXQgcmVzOiBSZXNwb25zZTtcblxuICB0cnkge1xuICAgIHJlcyA9IGF3YWl0IGV4ZWN1dGVXaXRoVGltZW91dChmZXRjaFdpdGhSZXRyaWVzLCBvcHRpb25zLnRpbWVvdXQsICgpID0+XG4gICAgICBjb250cm9sbGVyLmFib3J0KCksXG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIHJlcy5oZWFkZXJzLmtleXMoKSkge1xuICAgIGhlYWRlcnNbaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpXSA9IHJlcy5oZWFkZXJzLmdldChoZWFkZXJOYW1lKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IHtcbiAgICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzLFxuICAgIGhlYWRlcnMsXG4gIH07XG4gIGlmIChmb2xsb3dSZWRpcmVjdCAmJiBpc1JlZGlyZWN0KHJlc3BvbnNlLnN0YXR1c0NvZGUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBlcmZvcm1SZWRpcmVjdFJlcXVlc3QoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBmb2xsb3dSZWRpcmVjdCxcbiAgICAgICAgY291bnRlcixcbiAgICAgICAgKHJlcSkgPT5cbiAgICAgICAgICBzdGFydEZldGNoUmVxdWVzdChcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBlbWl0dGVyLFxuICAgICAgICAgICAgY291bnRlciArIDEsXG4gICAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGVtaXR0ZXIuZW1pdCgncmVzcG9uc2UnLCByZXNwb25zZSk7XG4gIHJlcy5ib2R5LnBpcGUob3V0cHV0KTtcbn1cblxuLyoqXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXF1ZXN0KFxuICByZXE6IEh0dHBSZXF1ZXN0LFxuICBvcHRpb25zXzogSHR0cFJlcXVlc3RPcHRpb25zID0ge30sXG4pOiBEdXBsZXgge1xuICBjb25zdCBvcHRpb25zID0geyAuLi5kZWZhdWx0cywgLi4ub3B0aW9uc18gfTtcbiAgY29uc3QgeyBpbnB1dCwgb3V0cHV0LCBzdHJlYW0gfSA9IGNyZWF0ZUh0dHBSZXF1ZXN0SGFuZGxlclN0cmVhbXMoXG4gICAgcmVxLFxuICAgIG9wdGlvbnMsXG4gICk7XG4gIHN0YXJ0RmV0Y2hSZXF1ZXN0KHJlcSwgb3B0aW9ucywgaW5wdXQsIG91dHB1dCwgc3RyZWFtKTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuY29uc3Qgc2xlZXAgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgbXMpKTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLFNBQWlCQSxRQUFRLFFBQWtCLFFBQVE7QUFDbkQsT0FBT0MsS0FBSyxJQUFJQyxRQUFRLFFBQWlDLFlBQVk7QUFDckUsT0FBT0MscUJBQXFCLE1BQU0sbUJBQW1CO0FBQ3JELFNBQ0VDLCtCQUErQixFQUMvQkMsa0JBQWtCLEVBQ2xCQyxVQUFVLEVBQ1ZDLHNCQUFzQixRQUNqQixrQkFBa0I7QUFFekIsU0FBU0MsU0FBUyxRQUFRLGVBQWU7QUFDekMsT0FBT0MsRUFBRSxNQUFNLGtCQUFrQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsUUFBNEIsR0FBRyxDQUFDLENBQUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLE9BQU8sU0FBU0MsV0FBV0EsQ0FBQ0MsU0FBNkIsRUFBRTtFQUN6REYsUUFBUSxHQUFHRSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUZBLFNBR2VDLGlCQUFpQkEsQ0FBQUMsRUFBQSxFQUFBQyxHQUFBLEVBQUFDLEdBQUEsRUFBQUMsR0FBQSxFQUFBQyxHQUFBO0VBQUEsT0FBQUMsa0JBQUEsQ0FBQUMsS0FBQSxPQUFBQyxTQUFBO0FBQUE7QUFrTWhDO0FBQ0E7QUFDQTtBQUZBLFNBQUFGLG1CQUFBO0VBQUFBLGtCQUFB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